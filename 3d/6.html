<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Canvas Image Warp (Gaussian Blend)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      margin: 10px auto;
      border: 1px solid #ccc;
    }
    input {
      display: block;
      margin: 5px auto;
    }
    .file-group {
      text-align: center;
      margin: 10px;
    }
    .wrapper {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .canvas-container {
      margin: 10px;
    }
  </style>
</head>
<body>
  <!-- Inputs for images -->
  <div class="file-group">
    <label>
      Source Pattern:
      <input type="file" id="sourcePatternInput" accept="image/png,image/jpeg"/>
    </label>
  </div>
  <div class="file-group">
    <label>
      Destination Pattern:
      <input type="file" id="destPatternInput" accept="image/png,image/jpeg"/>
    </label>
  </div>
  <div class="file-group">
    <label>
      Image to Distort:
      <input type="file" id="distortedImageInput" accept="image/png,image/jpeg"/>
    </label>
  </div>

  <!-- Gaussian parameters -->
  <div class="file-group">
    <label>
      Kernel Radius:
      <input type="number" id="kernelRadius" value="3" min="0" max="50" />
    </label>
    <label>
      Sigma:
      <input type="number" id="sigma" step="0.1" value="2.0" min="0.1" max="50" />
    </label>
    <label>
      Opacity Factor:
      <input type="number" id="opacityFactor" step="0.1" value="1.0" min="0" max="1" />
    </label>
    <button id="applyDistortionBtn">Re-Apply Distortion</button>
  </div>

  <!-- Canvases -->
  <div class="wrapper">
    <div class="canvas-container">
      <h3 style="text-align:center;">Source Pattern</h3>
      <canvas id="sourceCanvas" width="512" height="512"></canvas>
    </div>
    <div class="canvas-container">
      <h3 style="text-align:center;">Destination Pattern</h3>
      <canvas id="destCanvas" width="512" height="512"></canvas>
    </div>
    <div class="canvas-container">
      <h3 style="text-align:center;">Image to Distort</h3>
      <canvas id="distortCanvas" width="512" height="512"></canvas>
    </div>
    <div class="canvas-container">
      <h3 style="text-align:center;">Result</h3>
      <canvas id="resultCanvas" width="512" height="512"></canvas>
    </div>
  </div>

  <script>
    // Grab all canvas elements
    const sourceCanvas   = document.getElementById('sourceCanvas');
    const destCanvas     = document.getElementById('destCanvas');
    const distortCanvas  = document.getElementById('distortCanvas');
    const resultCanvas   = document.getElementById('resultCanvas');

    // 2D contexts
    const sourceCtx   = sourceCanvas.getContext('2d');
    const destCtx     = destCanvas.getContext('2d');
    const distortCtx  = distortCanvas.getContext('2d');
    const resultCtx   = resultCanvas.getContext('2d');

    // colorToCoordMap[colorKey] = { x, y } in source pattern
    let colorToCoordMap = {};

    // Track if images are loaded
    let sourceLoaded    = false;
    let destLoaded      = false;
    let distortedLoaded = false;

    // File input event listeners
    document.getElementById('sourcePatternInput').addEventListener('change', handleSourcePattern);
    document.getElementById('destPatternInput').addEventListener('change', handleDestPattern);
    document.getElementById('distortedImageInput').addEventListener('change', handleDistortedImage);

    // "Re-Apply Distortion" button
    document.getElementById('applyDistortionBtn').addEventListener('click', () => {
      // If images are already loaded, just re-run the mapping with updated Gaussian params
      if (sourceLoaded && destLoaded && distortedLoaded) {
        applyDistortionWithGaussian();
      }
    });

    // --------------------------------------------------
    // 1) Load Source Pattern
    // --------------------------------------------------
    function handleSourcePattern(e) {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
        sourceCtx.drawImage(img, 0, 0, sourceCanvas.width, sourceCanvas.height);
        sourceLoaded = true;
        tryMappingIfAllLoaded();
      };
      img.src = URL.createObjectURL(file);
    }

    // --------------------------------------------------
    // 2) Load Destination Pattern
    // --------------------------------------------------
    function handleDestPattern(e) {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        destCtx.clearRect(0, 0, destCanvas.width, destCanvas.height);
        destCtx.drawImage(img, 0, 0, destCanvas.width, destCanvas.height);
        destLoaded = true;
        tryMappingIfAllLoaded();
      };
      img.src = URL.createObjectURL(file);
    }

    // --------------------------------------------------
    // 3) Load the Image to Distort
    // --------------------------------------------------
    function handleDistortedImage(e) {
      const file = e.target.files[0];
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        distortCtx.clearRect(0, 0, distortCanvas.width, distortCanvas.height);
        distortCtx.drawImage(img, 0, 0, distortCanvas.width, distortCanvas.height);
        distortedLoaded = true;
        tryMappingIfAllLoaded();
      };
      img.src = URL.createObjectURL(file);
    }

    // --------------------------------------------------
    // Once all 3 images are loaded, build map + apply distortion
    // --------------------------------------------------
    function tryMappingIfAllLoaded() {
      if (sourceLoaded && destLoaded && distortedLoaded) {
        buildColorToCoordMap();
        applyDistortionWithGaussian();
      }
    }

    // --------------------------------------------------
    // Build color -> (x,y) coordinate map from Source Pattern
    // We'll read each pixel's RGB in the Source Pattern,
    // store the coordinate for that color.
    // --------------------------------------------------
    function buildColorToCoordMap() {
      colorToCoordMap = {};

      const srcData = sourceCtx.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);
      const w = sourceCanvas.width;
      const h = sourceCanvas.height;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          const r = srcData.data[i + 0];
          const g = srcData.data[i + 1];
          const b = srcData.data[i + 2];
          // alpha: srcData.data[i + 3]

          const key = `${r},${g},${b}`;
          
          // Store the coordinate.
          // NOTE: If multiple pixels share the same color, the last one encountered
          // will override. For many designs, that might be okay, but for others
          // you may need a different approach (e.g. store an array).
          colorToCoordMap[key] = { x, y };
        }
      }
    }

    // --------------------------------------------------
    // Gaussian Function
    // A simple 2D Gaussian for weighting
    // --------------------------------------------------
    function gaussian(dx, dy, sigma) {
      return Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
    }

    // --------------------------------------------------
    // Apply Distortion Using Gaussian Neighborhood
    // --------------------------------------------------
    function applyDistortionWithGaussian() {
      const destData = destCtx.getImageData(0, 0, destCanvas.width, destCanvas.height);
      const w = destCanvas.width;
      const h = destCanvas.height;

      const distortedData = distortCtx.getImageData(0, 0, distortCanvas.width, distortCanvas.height);
      const dw = distortCanvas.width;

      // Create a blank result
      const resultData = resultCtx.createImageData(w, h);

      // Read user parameters
      const kernelRadius = parseInt(document.getElementById('kernelRadius').value, 10) || 3;
      const sigma        = parseFloat(document.getElementById('sigma').value) || 2.0;
      const opacityFactor= parseFloat(document.getElementById('opacityFactor').value) || 1.0;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {

          // Index in the dest pattern
          const idx = (y * w + x) * 4;
          const rD  = destData.data[idx + 0];
          const gD  = destData.data[idx + 1];
          const bD  = destData.data[idx + 2];
          // alpha: destData.data[idx + 3]

          // Look up the coordinate from the source pattern
          const key = `${rD},${gD},${bD}`;
          const coord = colorToCoordMap[key];

          if (!coord) {
            // If we can't find this color in the source pattern, skip or set transparent
            resultData.data[idx + 0] = 0;
            resultData.data[idx + 1] = 0;
            resultData.data[idx + 2] = 0;
            resultData.data[idx + 3] = 0;
            continue;
          }

          // (sx, sy) in the "Distorted Image" that corresponds to the center of our kernel
          const sx = coord.x;
          const sy = coord.y;

          // Accumulate color
          let sumR = 0, sumG = 0, sumB = 0, sumA = 0;
          let weightSum = 0;

          // Neighborhood from -kernelRadius to +kernelRadius
          for (let ny = -kernelRadius; ny <= kernelRadius; ny++) {
            for (let nx = -kernelRadius; nx <= kernelRadius; nx++) {
              const xx = sx + nx;
              const yy = sy + ny;

              // Bounds check
              if (xx < 0 || xx >= dw || yy < 0 || yy >= distortCanvas.height) {
                continue;
              }
              
              // Distorted image index
              const i2 = (yy * dw + xx) * 4;

              const r2 = distortedData.data[i2 + 0];
              const g2 = distortedData.data[i2 + 1];
              const b2 = distortedData.data[i2 + 2];
              const a2 = distortedData.data[i2 + 3];

              // Weight based on distance from the center
              const wG = gaussian(nx, ny, sigma);

              sumR += r2 * wG;
              sumG += g2 * wG;
              sumB += b2 * wG;
              sumA += a2 * wG;
              weightSum += wG;
            }
          }

          if (weightSum > 0) {
            // Normalize
            const outR = sumR / weightSum;
            const outG = sumG / weightSum;
            const outB = sumB / weightSum;
            const outA = (sumA / weightSum) * opacityFactor; // adjust alpha by user factor

            resultData.data[idx + 0] = outR;
            resultData.data[idx + 1] = outG;
            resultData.data[idx + 2] = outB;
            resultData.data[idx + 3] = outA;  // 0..255
          } else {
            // fallback
            resultData.data[idx + 0] = 0;
            resultData.data[idx + 1] = 0;
            resultData.data[idx + 2] = 0;
            resultData.data[idx + 3] = 0;
          }
        }
      }

      // Draw final
      resultCtx.putImageData(resultData, 0, 0);
    }
  </script>
</body>
</html>

